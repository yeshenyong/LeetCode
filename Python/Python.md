# Python



### 标识符命名规则

约定俗成的命名规则

| 类型       | 规则                                                         | 例子             |
| ---------- | ------------------------------------------------------------ | ---------------- |
| 模块和包名 | 全小写字母，尽量简单。若多个单词之间用下划线                 | math、os、sys    |
| 函数名     | 全小写字母，多个单词之间用下划线隔开                         | phone、my_name   |
| 类名       | 首字母大写，采用驼峰规则。多个单词时每个单词第一个字母大写，其余部分小写 | MyPhone、MyClass |
| 常量名     | 全大写字母，多个单词使用下划线隔开                           | SPEED、MAX_SPEED |





a = 123。运行过程中，解释器先运行右边的表达式，生成一个代表表达式运算结果的对象；然后，将这个对象地址复制给左边的变量



### 删除变量和垃圾回收机制

```python
a=123
del a
```

如果123这个对象没有变量引用了，就会被垃圾回收机制所回收，清空内存空间。



### 链式赋值

```python
x=y=123 equal x=123 y=123
```



### 系列解包赋值

```python
a, b, c=4,5,6 equal to
a = 4
b = 5
c = 6
```

使用系列解包赋值实现变量互换

```python
a,b=1,2
a,b=b,a
print(a,b)
```



### 常量

Python不支持常量，即没有语法规则限制改变一个变量的值。我们只能约定常量的命名规则，以及在程序的逻辑上不对常量的值作出修改。



`divmod` 返回是一个元组

```python
divmod(13, 3)
(4, 1)	# 同时获得商和余数
```





### 整数缓存问题

Python仅仅对比较小的整数对象进行缓存（范围为[-5, 256]）缓存起来

is 用户判断两个变量引用对象是否为同一个

== 用于判断引用变量引用对象的值是否相等，默认调用对象的 ____eq____() 方法

解释器做了一部分优化（范围是[-5, 任意正整数]）

临时缓存



- is 比较两个对象的id 值是否相等，是否指向同一个内存地址
-  == 比较的事两个对象的内容是否相等，值是否相等
- 小数对象[-5, 256]在全局解释器范围内被放入缓存供重复使用
- is 运算符比 == 效率高，**在变量和None 进行比较时，应该使用 is**



### 字符串

字符串的本质是：字符序列。Python的字符串是不可变得，我们无法对原字符做任何修改。但，可以将字符串的一部分复制到新创建的字符串，达到“看起来修改”的效果。

​	Python不支持单字符类型，单字符也是作为一个字符串使用的。



Python3 直接支持unicode，可表示世界上任何语言字符

内置函数`ord()`可以把字符转换对应的unicode码

内置函数`chr()`可以把十进制数学转换成对应的字符



连续三个单引号或者三个双引号，可以帮助我们创建多行字符串

```python
resume = ''' "tom = 123" '''
```



### 转义字符

| 转义字符 | 描述            |
| -------- | --------------- |
| \        | 续行符          |
| \\\      | 反斜杠符号      |
| \\'      | 单引号          |
| \\''     | 双引号          |
| \b       | 退格(Backspace) |
| \n       | 换行            |
| \t       | 横向制表符      |
| \r       | 回车            |



### 字符串复制

```python
a = 'sxt' * 3
```



不换行打印

```python
print("", end='')
print("", end',')
```



从控制台读取字符串

```python
myname = input("请输入名字")
myname
```



### 字符串切片

slice操作

切片slice 操作可以让我们快速的提取子字符串。标准格式为

[起始偏移量 start:终止偏移量 end: 步长 step]



| 操作和说明                                        | 示例                       | 结果      |
| ------------------------------------------------- | -------------------------- | --------- |
| [:] 提取整个字符串                                | “abcdef” [:]               | "abcdef"  |
| [start:] 从start索引开始到结尾                    | "abcdef"[2:]               | "cdef"    |
| [:end] 从头开始直到end - 1                        | "abcdef"[:2]               | "ab"      |
| [start:end] 从start 到 end-1                      | "abcdef" [2:4]             | "cd"      |
| [start: end:step] 从start 提取到end-1，步长是step | "abcdef" [1:5:2]           | ”bd“      |
| "abcdefghijklmno"[-3:]                            | 倒数三个                   | "mno"     |
| ”abcdefghijklmno“[-8, -3]                         | 倒数第八个到倒数第三个     | "jklmno"  |
| ”abcdefghijklmno“[::-1]                           | 步长为负，从右到左反向提取 | onmlkj... |



切片操作时，起始偏移量和终止偏移量不在[0, 字符串长度-1]这个范围，也不会报错。起始偏移量小于0则会当做0，终止偏移量大于”长度-1“会被当成-1.



### split() 分割、join() 合并

split 可以基于分隔符将字符串分割成多个子字符串（存储到列表中）。如果不指定分隔符，则默认使用空白字符（换行符、空格、制表符）



join 的作用和split恰好相反，用于将一系列字符串连接起来

```
a = ['xst', 'xst', 'xst200']
'*',join(a)
'xst*xst*xst200'
```



#### **拼接字符串要点**

​	使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐使用join函数，因为join函数会拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象。

```python
for i in range(100000):	
    a += 'sxt'

li = []
for i in range(100000):
    li.append("sxt")
str1 = "".join(li)
```



**join后者，速度快4~60倍，字符串+号一定要少写**



### 字符串驻留机制

​	字符串驻留：仅保存一份且不可变字符串的方法，不同的值被存放在字符串驻留池中，Python支持字符串驻留机制，对于符合标识符规则的字符串（不同Python版本不一样会不一致）回启东字符串驻留机制





### 常用查找方法

| 方法         | 说明                         | 结果 |
| ------------ | ---------------------------- | ---- |
| len(a)       | 字符串长度                   |      |
| a.startswith | 以指定字符串开头             |      |
| a.endswith   | 以指定字符串结尾             |      |
| a.find       | 第一次出现指定字符串的位置   |      |
| a.rfind      | 最后一次出现指定字符串的位置 |      |
| a.count      | 指定字符串出现次数           |      |
| a.isalnum()  | 所有字符全是字母或数字       |      |
| strip()      | 去除首尾指定信息             |      |
| lstrip       | 去除字符串左边指定信息       |      |
| rstrip       | 去除字符串右边指定信息       |      |



### 大小写转换

| 示例         | 说明                                 | 结果 |
| ------------ | ------------------------------------ | ---- |
| a.capitalize | 产生新的字符串，首字母大写           |      |
| a.title      | 产生新的字符串，每个单词都首字母大写 |      |
| a.upper      | 产生新的字符串，所有字符全转成大写   |      |
| a.lower      | 产生新的字符串，所有字符串全转为小写 |      |
| a.swapcase   | 产生新的，所有字母大小写转换         |      |



### 格式排版

center()、ljust()、rjust() 三个函数用于对字符串实现排版

```python
a = "SXT"
a.center(10, "*")
'***SXT****'
a.center(10)
'   SXT    '
a.ljust(10, "*")
'SXT*******'
```



其他方法

1. isalnum()	 是否为字母或数字
2. isalpha()      检测字符串是否有字母组成（含汉字）
3. isdigit() 检测字符串是否只由数字组成
4. isspace() 检测是否为空白符
5. isupper() 是否为大写字母
6. islower() 是否为小写字母



**空白符=> 制表符、换行符、空格**



### format() 基本用法

format 代替以前的%

Python2.6开始

```python
print("{0} = {1}".format("1", "2"))

print("{name} = {age}".format(name=123, age=123))
```

我们可以通过{索引}/{参数名}，直接映射参数值，实现对字符串的格式化，非常方便



**填充与对齐**

填充常跟对齐一起使用

^、<、>分别是居中、左对齐、右对齐，后面带宽度

:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充

```python
>>> "{:*>8}".format("245")
'*****245'
>>> “我是{0}, 我喜欢数字{1:*^8}".format(“高琪", "666")
'我是高琪，我喜欢数字**666***'
```



### 可变字符串

在Python中欧个，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能创建新的字符串对象。但是，经常我们确实需要原地修改字符换，可以使用io.StringIO对象或array模块

```python
import io
s = "hello.txt"
sio = io.StringIO(s)
sio

sio.getvalue()
sio.seek()
sio.write("g")
sio.getvalue()
```



乘法操作

列表、元组等复制 [10, 20, 30] * 3 ==> [10, 20, 30, 10, 20, 30, 10, 20, 30]



Python 不支持自增和自减



### 序列

​	序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的内存空间。

​	由于Python一切皆模块、对象

**序列中存储的整数对象的地址，而不是整数对象的值。**

a = [10, 20, 30]

a存的是列表的地址

列表里面存的是10，20，30的地址

#### 字符串

字符对象的序列



#### 列表

任意对象的序列

列表：可以存储任意数目、任意类型的数据集合、连续的内存空间

| 方法               | 要点     | 描述                              |
| ------------------ | -------- | --------------------------------- |
| list.append(x)     | 增加元素 | 元素x增加到列表list尾部           |
| list.extend(alist) | 增加元素 | 列表alist所有元素加到列表list尾部 |
| list.insert        | 增加元素 | 在列表指定位置index处插入元素x    |

基本语法[]、list()、range() 创建

```python
a = list("gaoqi")
range(10)
a = list(range(10)) -> [0, 1, ..., 9]
```

range() 创建整数列表

range([start, ] end [, step])

```python
list(range(3, -10, -1))
list(range(15, 3, -1))
list(range(3, 15, 2))
```



推导式生成列表

```python
a = [x*2 for x in range(5)]
a = [x*2 for x in range(100) if x%9 == 0] #通过if过滤元素
a = [0, 18,36, ... , 198]
```

列表的元素增加和删除

当列表删除和增加涉及到列表元素的大量移动，效率较低。O(n)

**append() 方法**

​	**原地修改列表对象是真正的列表尾部添加新的元素，速度最快，推荐使用**

**+运算符操作**

​	并不是真正的尾部添加元素，而是创建新的列表对象，将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用

**extend() 方法**

将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。

**insert() 插入元素**

造成大量复制O(n)

remove()、pop()、del() 删除非尾部元素都会发生后面元素的移动

乘法扩展

```python
a= ['sxt', 100]
b = a*3
b
['sxt', 100, 'sxt', 100, 'sxt', 100]
```



**index() 获得指定元素首次出现的索引位置。语法是: index(value, [start, [end]])**

start、end 指定了搜索范围



**count() 获得指定元素在列表总出现次数**



**成员资格判断**

in 判断



**切片操作**

slice操作可以让我们快速的提取子列表或修改。

标准格式为：[起始偏移量 start:终止偏移量 end:[步长 step]]

步长省略时顺便可以省略第二个冒号



列表的遍历

```python
for obj in listObj:
	print(obj)
```



**列表排序**

修改原列表，不建新列表的排序

```python
a.sort() # 默认升序排序

a.sort(reverse=True) # 降序排列

import random
random.shuffle(a)

```



建新列表排序

sorted() 排序

```python
a = sorted(a) # 默认升序
a = sorted(a, reverse=True)
```



**reversed() 返回迭代器**

时间换空间

reversed() 不对原列表做任何修改，知识返回一个逆序排列的迭代器对象



**max、min、sum**





Python列表大小可变，根据需要随时增加或缩小

​	字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。所有二者用法几乎一模一样.





#### 元组

tuple

列表属于可变序列，可以任意修改列表中元素。

元组属于不可变序列，不能修改元组中的元素。

元祖没有增删改元素方法。

支持一下操作:

- 索引访问
- 切片操作
- 连接操作
- 成员关系操作
- 比较运算操作
- 计数：元素长度、最大值最小值



**tuple创建**

```python
tuplea = ()

tuplea = tuple(元素对象)

tuplea = (20, ) # 一定逗号 
```



切片完还是它本身

列表和元组本质区别不能修改

​	**列表关于排序的方法list.sorted() 是修改原列表，元组没有该方法。如果要对元组排序，只能使用内置函数sorted(tupleObj)，并生成新的列表对象**



​	**zip(列表1，列表2，...) 将多个对象对应位置的元素组成为元组，并返回这个zip对象**

```python
a = [10, 20, 30]
b = [40, 50, 60]
c = [70, 80, 90]
d = zip(a, b, c)
list(d)
[(10, 40, 70), (20, 50, 80), (30, 60, 90)]
```



序列解包

```python
x, y, z = (20, 30, 10)
[a, b, c] = [10, 20, 30]
```



生成器推导式创建元祖

s = (x*2 for x  in range(5))

​	我们通过生成器对象，转换成列表或者元祖。也可以使用生成器对象的____next____() 方法来进行遍历，或者直接作为迭代器对象来使用。不管什么方式使用，**元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象。**



```python
s = (x*2 for x  in range(5))
s
tuple(s)
list(s) # 只能放问一次元素，第二次就为空。需要再生成一次
s
```



```python
s = (x*2 for x in range(5))
s.__next__()
s.__next__()
```



元组总结

- 元组的核心特点是：不可变序列
- 元组的访问和处理速度比列表快
- 与整数和字符串一样，元组可以作为字典的键，列表则永远不能做为字典的键使用



#### 字典

字典是“键值对” 的无序可变序列

可以通过{}、dict() 来创建字典对象

列表、字典、集合这些可变对象不能作为键，并键不可重复



##### **通过zip() 创建字典对象**

```python
k = ['name', 'age', 'job']
v = ['gaoqi', 18, 'teacher']
d = dict(zip(k, v))
d
id2word = dict(zip(word2id.values(), word2id.keys()))
```

```python
a = dict([("name", "gaoqi"), ("age", 18)])
>>> a
{'name': 'gaoqi', 'age': 18}
```

##### fromkeys

通过fromkeys 创建值为空的字典

```python
a = dict.fromkyes(['name', 'age', 'job'])
>>> a
{'name':None, 'age':None, 'job':None}
```



​	通过get() 方法获得"值"。推荐使用，优点是：指定键不存在，返回None；也可以设定指定键不存在时默认返回的对象。推荐使用get() 获取"值对象"

```python
a.get('name')
a.get('sex', '一個男人')
a.get('name', '不存在')
```



列出所有键值对

a.items()

遍历

```python
for k, v in a.items():
	print k
	print v
```



列出所有的键，列出所有的值

```python
a.keys()
# put in list
b.values()
# put in list
```



**键值对的个数**

len()



检测一个"键"是否在字典中

```python
"name" in a

True
```



**添加、修改、删除**

添加

a['address']  = 123



​	update() 将新字典中所有键值对全部添加到旧字典对象上。如果key有重复，则直接覆盖。

```python
a = {'name':'yeshenyong'}
b = {'name':'hazayan'}
a.update(b)
>>> a
{'name', 'hazayan'}
```

删除

del() 方法、clear() 删除所有键值对、pop() 删除指定键值对并返回对应“值对象”

```python
a = {'name':'gaoqi', 'age':18, 'job':nono}
del(a['name'])
{'age':18, 'job':nono}
b = a.pop('age')
>>> b
18
```



**popitem()**

​	随机删除和返回该键值对。字典是“无需可变序列”，因此没有第一个元素、最后一个元素的概念；popitem 弹出随机的项，因为字典没有“最后的元素”或者其他有关顺序的概念。若想一个个移除并处理项，这个方法很有效

```python
a = {'name':'gaoqi', 'age':18, 'job':nono}
a.popitem()
('job', 'nono')
a
a.popitem()
('age', 18)
a.popitem()
('name', 'gaoqi')
```



字典序列解包

```python
s = {'name':'gaoqi','age':18,'job':'teacher'}
name, age, job = s # 默认对键进行操作
>>> name
'name'
name. age, job = s.items() # 对键值对进行操作
>>> name
('name', 'gaoqi')
name, age, job = s.values() # 对值进行操作
>>> name
'gaoqi'
```



字典核心底层原理

哈希表bucket

总结：

1. 键必须可hash
   1. 数字、字符串、元组都是可散列的
   2. 自定义对象需要支持下面三点
      1. 支持hash() 函数
      2. 支持通过____eq____() 方法检测相等性
      3. 若 a == b 为真，则hash(a) == hash(b) 也为真
2. 字典在内存中开销巨大，典型的空间换时间
3. 键查询速度很快
4. 往字典里面添加新建可能导致扩容，导致hash表中键的次序变化







#### 集合

本质上就是字典

无值的字典

```python
a = {1, 3, 'sxt'}
b = {'he', 'it', 'sxt'}
a | b
a & b
a - b
a.union(b)
a.intersection(b)
a.differencce(b)
```



赋值语句不可出现在if-else 中

三元条件运算符

print(num if int(num) < 10 else “数字太大")

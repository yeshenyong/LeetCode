# Python 多线程为什么那么慢



### 多线程慢

- 特点无法利用多核，无法实现真正意义上是并行效果
- 优点：对于IO 密集型的操作可以很好利用IO 阻塞的时间

python的多线程在同一时刻只会有一条线程跑在CPU里面，其他线程都在睡觉。



### 为什么慢

#### 全局解释器锁（GIL）

**Global Interpreter Lock**

> Guido van Rossum（吉多·范罗苏姆）创建python时就只考虑到单核cpu，解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁， 于是有了GIL这把超级大锁。因为cpython解析只允许拥有GIL全局解析器锁才能运行程序，这样就保证了保证同一个时刻只允许一个线程可以使用cpu。由于大量的程序开发者接收了这套机制,现在代码量越来越多,已经不容易通过c代码去解决这个问题

这玩意直接搞死

> 现代计算机的CPU通常是多核的，并且有些拥有多个处理器。为了充分利用多余的处理能力，操作系统定义了一种低级的结构叫做线程：一个进程（例如Chrome浏览器）可以产生多个线程并且指导内部系统。

如果一个进程是CPU密集型，那么其负载可以被多核同时处理，从而有效提高大多数应用的速度。

当CPython创建变量时，它会预先分配存储空间，然后计算当前变量的引用数目。这个概念被称为引用计数。如果引用计数为零，那么它将从系统中释放对应存储区域。

这就是为什么在CPython中创造“临时”变量不会使应用占用大量的存储空间——尤其是当应用中使用了for循环这一类可能大量创建“临时”变量的结构时。

当存在多个线程调用变量时，CPython如何锁住引用计数成为了一个挑战。而“全局解释锁”应运而生，它能够谨慎控制线程的执行。无论有多少的线程，解释器每次只能执行一个操作。

这对Python的性能意味着什么呢？

如果你的应用基于单线程、单解释器，那么讨论速度这一点就毫无意义，因为去掉GIL并不会影响代码性能。

如果你想使用线程在单解释器（Python 进程）中实现并发，并且你的线程为IO密集型（例如网络IO或磁盘IO），你就会看到GIL争用的结果。

![img](http://5b0988e595225.cdn.sohucs.com/images/20180814/02121e2d0f164816931bef25c1ffdb13.png)

##### 什么时候会释放Gil锁

答 : 
 1 遇到像 i/o操作这种 会有时间空闲情况 造成cpu闲置的情况会释放Gil
 2 会有一个专门ticks进行计数 一旦ticks数值达到100 这个时候释放Gil锁 线程之间开始竞争Gil锁(说明:
     ticks这个数值可以进行设置来延长或者缩减获得Gil锁的线程使用cpu的时间)

#### 解释性语言而非编译语言

#### 动态类型语言

在静态类型语言中，定义变量时必须声明类型。C, C++, Java, C#, Go都是这种语言。

在动态类型语言中，类型的概念依旧存在，但是这个变量的类型是动态变化的。

a = 1a = "foo"

在上面这个例子中，Python创建第二个变量的时候用了同样的名字，但是变量类型是str（字符型），这样就对先前在内存中给a分配的空间进行了释放和再分配。

静态类型语言的这种设计并不是为了麻烦大家——它们是按照CPU的运行方式设计的。如果最终需要将所有内容都转化为简单的二进制操作，那就必须将对象和类型转换为低级数据结构。

Python自动完成了这个过程，我们看不见，也没必要看见。

不必声明类型不是使Python变慢的原因。Python语言的设计使我们几乎可以创建任何动态变量。我们可以在运行时替换对象中的方法，也可以胡乱地把低级系统调用赋给一个值。几乎怎么修改都可以。

正是这种设计使得优化Python变得异常困难。

### 解决方法

1. 使用多进程替代多线程
2. 用C编写多线程，python调用

注意

> 多线程并不会充分调用两个CPU，而是会像在一个CPU上充分运转，而多进程则是会完全调用两个CPU，同时执行



借鉴

https://blog.csdn.net/weixin_41594007/article/details/79485847

https://blog.csdn.net/sinat_38682860/article/details/82115422
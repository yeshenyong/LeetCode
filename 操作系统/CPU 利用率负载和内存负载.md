# CPU 利用率负载和内存负载

如果在服务器上面切承载业务CPU控制在50以内 内存80以内

### CPU

CPU 正常范围

> 只要不卡都是正常

可能你认为的 90% CPU 利用率意味着这样的情形：



![img](https://pic4.zhimg.com/v2-d13b5fad6d9bbed1b26810d816aeefff_r.jpg)



而实际却可能是这样的：



![img](https://pic3.zhimg.com/v2-8858646f5d96b203578f96186ef7c57e_r.jpg)

CPU使用率其实就是你运行的程序占用的CPU资源，表示机器在某个时间点的运行程序的情况。

> 理想情况下，每个 CPU 应该满负荷工作，并且没有等待进程，此时，平均负载 = CPU 逻辑核数。
>
> 但是，在实际生产系统中，不建议系统满负荷运行。通用的经验法则是：平均负载 = 0.7 * CPU 逻辑核数。
>
> 当平均负载持续大于 0.7 * CPU 逻辑核数，就需要开始调查原因，防止系统恶化；
>
> 当平均负载持续大于 1.0 * CPU 逻辑核数，必须寻找解决办法，降低平均负载；
>
> 当平均负载持续大于 5.0 * CPU 逻辑核数，表明系统已出现严重问题，长时间未响应，或者接近死机

**CPU使用率只要不是一直都是50%以上，都算是正常的。在没运行其它程序的情况下，CPU使用率小于15％也是正常的。**

提到CPU利用率，就必须理解时间片。什么是CPU时间片？我们现在所使用的Windows、Linux、Mac OS都是“多任务操作系统”，就是说他们可以“同时”运行多个程序，比如一边打开Chrome浏览器浏览网页还能一边听音乐。

但是，实际上一个CPU内核在同一时刻只能干一件事，那操作系统是如何实现“多任务”的呢？大概的方法是让多个进程轮流使用CPU一小段时间，由于这个“一小段时间”很短(在linux上为5ms-800ms之间)，用户感觉不到，就好像是几个程序同时在运行了。上面提到的“一小段时间”就是我们所说的CPU时间片，CPU的现代分时多任务操作系统对CPU都是分时间片使用的

CPU使用率，就是程序对CPU时间片的占用情况，即CPU使用率 = CPU时间片被程序使用的时间 / 总时间。比如A进程占用10ms，然后B进程占用30ms，然后空闲60ms，再又是A进程占10ms，B进程占30ms，空闲60ms，如果在一段时间内都是如此，那么这段时间内的CPU占用率为40%。CPU利用率显示的是程序在运行期间实时占用的CPU百分比。

大多数操作系统的CPU占用率分为用户态CPU使用率和系统态CPU使用率。用户态CPU使用率是指执行应用程序代码的时间占总CPU时间的百分比。相比而言，系统态CPU使用率是指应用执行操作系统调用的时间占总CPU时间的百分比。系统态的CPU使用率高意味着共享资源有竞争或者I/O设备之间有大量的交互。

而CPU负载显示的是一段时间内正在使用和等待使用CPU的平均任务数。

简单理解，一个是CPU的实时使用情况，一个是CPU的当前以及未来一段时间的使用情况。举例来说：如果我有一个程序它需要一直使用CPU的运算功能，那么此时CPU的使用率可能达到100%，但是CPU的工作负载则是趋近于“1”，因为CPU仅负责一个工作嘛！如果同时执行这样的程序两个呢？CPU的使用率还是100%，但是工作负载则变成2了。所以也就是说，CPU的工作负载越大，代表CPU必须要在不同的工作之间进行频繁的工作切换。无论CPU的利用率是高是低，跟后面有多少任务在排队(CPU负载)没有必然关系

可以通过uptime、w命令查看CPU平均负载，使用top命令还能看到CPU负载总体使用率以及各个进程占用CPU的比例

**超线程（Hyper-Threading ）**

超线程是Intel最早提出一项技术，最早出现在2002年的Pentium4上。单个采用超线程的CPU对于操作系统来说就像有两个逻辑CPU，为此P4处理器需要多加入一个Logical CPU Pointer（逻辑处理单元）。

虽然采用超线程技术能同时执行两个线程，但它并不像两个真正的CPU那样，每个CPU都具有独立的资源。当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。因此超线程的性能并不等于两颗CPU的性能

https://zhuanlan.zhihu.com/p/391447889

https://www.cnblogs.com/gatsby123/p/11127158.html



### 内存

如果在服务器上面切承载业务CPU控制在50以内 内存80以内

建议不要超过80%的占比


















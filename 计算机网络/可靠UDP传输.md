# 可靠UDP传输

# RUDP(Reliable UDP)

**既然已经有TCP了，为什么还需要UDP可靠？**

可靠：**个人理解就是确保数据方能完整接受包信息**

> ​	UDP实现的可靠协议，基本都会对TCP的某一部分进行加强，另外一部分进行削弱。因为：
> “实时性+可靠性+公平性” 三者不能同时保证，因此可以牺牲TCP的局部公平性来换取更好的实时性，或者更浪费点带宽，来实现更低的延迟。比如我实现的一般快速可靠协议，使用比tcp多浪费15%的带宽的代价，换取了平均延迟降低30%-40%，最大延迟降低两倍的传输效果，成功的用到了多个项目中：



TCP是强制的可靠性传输，其在IP协议的基础上，发送端对所有的数据进行定时重传，接受端对所有的数据进行排序，以此(当然还有很多其他的机制)来实现发送端是什么样子的，接受端就能接受到什么样子的数据。但是现实中有一些场景，我们并不需要如此固执的可靠性。

对于FPS游戏这种时效性要求非常高的游戏中，玩家最关心的是自己的射击结果和角色的存活与否，当有一个手雷扔过来时，对于被炸死的玩家而言，这颗手雷是必须要接收到的消息，而其他没有被炸到的玩家，仅需要看到手雷的爆炸动画或者是声音，其更关心的是自己现在的子弹，有没有将敌人爆头。我们不希望因为手雷的消息重传排队，而把射击玩家的结果确认消息延后，这对于TCP而言就力所不逮了。

我们看一张图：

![img](https://pic3.zhimg.com/80/v2-ffc7622be5c32a0694624b4e541dd486_720w.jpg)

在传输效率，传输代价和可靠性三个维度上，TCP在最左侧的这条线上，可靠性最高，但传输代价也很大，效率上不及UDP。UDP则在最右侧，只有传输效率，不保证可靠，传输代价也较低。我们如果需要在大约六角形的位置，选择一个折中的方案，那就是UDP可靠传输，即RUDP登场的时刻了。

**如何实现？**

##### 重传定时器

首先，为了保证可靠性，我们需要在发送数据的时候添加**重传定时器**，来保证丢失的数据会被重传。重传的定时器可以定时回调发送重传的数据，也支持将接收到ACK的数据从定时器中取出。

> ​	现在有了重传定时器，那每次发送数据的时候，应该给定时器设置多长的超时时间呢？最简单的可以设定一个固定的重传时间，最合理的应该针对每条传输链路的不同设置每个连接的合理时间--rto。为了找到rto时间，我们需要获取到每个数据包发送确认时间，即rtt时间，即数据从发送到接收到ACK确认之间的时间间隔。我们参照TCP的实现策略，可以给每个消息记录一个发送时间，当接收到ACK确认时，将此时的时间减去记录的发送时间就获取到了rtt时间。但这样有一个问题，当发生数据重传时接收到ACK，无法判断这个ACK是对初次发送数据的确认还是对重传数据的确认，此时只能将发生重传数据测量到的rtt	时间丢弃。所以又有第二种rtt计算策略，我们可以将发送时间记录在数据头中发送出去，接受端在发送确认ACK时，将这个时间戳抄下来顺着ACK返回，这样发送端接收到ACK确认时，就能准确的知道要确认数据的发送时间，由此来计算rtt时间。有了rtt时间，我们按照TCP的标准方法《TCP/TPxian详解卷一, P465》，计算rto时间。



## UDP的三角制约原则

**其实在实时通信领域存在一个三角平衡关系——成本、质量和时延三者的制约关系：**







![img](https://pic2.zhimg.com/80/v2-8ad7a1b698e3fad4815ecf0b01fbb3e1_720w.jpg)



​	也就是说投入的成本、获得的质量和通信的时延之间是一个三角制约 (LEQ) 关系，所以实时通信系统的设计者会在这三个制约条件下找到一个平衡点，TCP 属于通过增大延迟和传输成本来保证质量的通信方式，UDP 是通过牺牲质量来保证时延和成本的通信方式，所以在一些特定场景下 RUDP 更容易找到这样的平衡点。RUDP 是怎么去找这个平衡点的，就要先从 RUDP 的可靠概念和使用场景来分析。





## 实时通信中什么是“可靠”

**在实时通信过程中，不同的需求场景对可靠的需求是不一样的，我们在这里总体归纳为三类定义：**

> 1）尽力可靠：通信的接收方要求发送方的数据尽量完整到达，但业务本身的数据是可以允许缺失的。例如：音视频数据、幂等性状态数据。；
> 2）无序可靠：通信的接收方要求发送方的数据必须完整到达，但可以不管到达先后顺序。例如：文件传输、白板书写、图形实时绘制数据、日志型追加数据等；
> 3）有序可靠：通信接收方要求发送方的数据必须按顺序完整到达。

RUDP 是根据这三类需求和上节图中的三角制约关系来确定自己的通信模型和机制的，也就是找通信的平衡点。



## UDP 为什么要可靠

说到这里可能很多人会说：干嘛那么麻烦，直接用 TCP 好了！

确实很多人也都是这样做的，TCP 是个基于公平性的可靠通信协议，但是在一些苛刻的网络条件下 TCP 要么不能提供正常的通信质量保证，要么成本过高。为什么要在 UDP 之上做可靠保证，究其原因就是在保证通信的时延和质量的条件下尽量降低成本。

**RUDP 主要解决以下相关问题：**

**1）端对端连通性问题：**

一般终端直接和终端通信都会涉及到 NAT 穿越，TCP 在 NAT 穿越实现非常困难，相对来说 UDP 穿越 NAT 却简单很多，如果是端到端的可靠通信一般用 RUDP 方式来解决，场景有：端到端的文件传输、实时音视频传输、交互指令传输等等；

**2）弱网环境传输问题：**

在一些 Wi-Fi 或者 3G/4G 移动网下，需要做低延迟可靠通信，如果用 TCP 通信延迟可能会非常大，这会影响用户体验。例如：实时的操作类网游通信、语音对话、多方白板书写等，这些场景可以采用特殊的 RUDP 方式来解决这类问题；

**3）带宽竞争问题：**

有时候客户端数据上传需要突破本身 TCP 公平性的限制来达到高速低延时和稳定，也就是说要用特殊的流控算法来压榨客户端上传带宽，例如：直播音视频推流，这类场景用 RUDP 来实现不仅能压榨带宽，也能更好地增加通信的稳定性，避免类似 TCP 的频繁断开重连；

**4）传输路径优化问题：**

在一些对延时要求很高的场景下，会用应用层 relay 的方式来做传输路由优化，也就是动态智能选路，这时双方采用 RUDP 方式来传输，中间的延迟进行 relay 选路优化延时。还有一类基于传输吞吐量的场景，例如：服务与服务之间数据分发、数据备份等，这类场景一般会采用多点并联 relay 来提高传输的速度，也是要建立在 RUDP 上的（这两点在后面着重来描述）；

**5）资源优化问题：**

某些场景为了避免 TCP 的三次握手和四次挥手的过程，会采用 RUDP 来优化资源的占用率和响应时间，提高系统的并发能力，例如 QUIC。

不管哪类场景，都是要保证可靠性，也就是质量，那么在 UDP 之上怎么实现可靠呢？答案就是重传。





## 重传模式

IP 协议在设计的时候就不是为了数据可靠到达而设计的，所以 UDP 要保证可靠，就依赖于重传，这也就是我们通常意义上的 RUDP 行为。

**在描述 RUDP 重传之前先来了解下 RUDP 基本框架，如图：**







![img](https://pic4.zhimg.com/80/v2-a725361d0bb5e39d3402d75fd653b647_720w.jpg)



RUDP 分为发送端和接收端，每一种 RUDP 在设计的时候会做不一样的选择和精简，概括起来就是图中的单元。RUDP 的重传是发送端通过接收端 ACK 的丢包信息反馈来进行数据重传，发送端会根据场景来设计自己的重传方式，重传方式分为三类：**定时重传、请求重传和 FEC 选择重传。**



## 定时重传

定时重传很好理解，就是发送端如果在发出数据包（T1）时刻一个 RTO 之后还未收到这个数据包的 ACK 消息，那么发送端就重传这个数据包。这种方式依赖于接收端的 ACK 和 RTO，容易产生误判，主要有两种情况：

> 1）对方收到了数据包，但是 ACK 发送途中丢失；
> 2）ACK 在途中，但是发送端的时间已经超过了一个 RTO。

​	所以超时重传的方式主要集中在 RTO 的计算上，如果你的场景是一个对延迟敏感但对流量成本要求不高的场景，就可以将 RTO 的计算设计得比较小，这样能尽最大可能保证你的延时足够小。

​	例如：实时操作类网游、教育领域的书写同步，是典型的用 expense 换 latency 和 quality 的场景，适合用于小带宽低延迟传输。如果是大带宽实时传输，定时重传对带宽的消耗是很大的，极端情况会有 20% 的重传率，所以在大带宽模式下一般会采用请求重传模式。



## 请求重传（*）

请求重传就是接收端在发送 ACK 的时候携带自己丢失报文的信息反馈，发送端接收到 ACK 信息时根据丢包反馈进行报文重传。

**如下图：**







![img](https://pic4.zhimg.com/80/v2-5136e2fe4314ecf54ee73ddd326c9d5b_720w.jpg)



这个反馈过程最关键的步骤就是回送 ACK 的时候应该携带哪些丢失报文的信息，因为 UDP 在网络传输过程中会乱序会抖动，接收端在通信的过程中要评估网络的 jitter time，也就是 rtt_var（RTT 方差值），当发现丢包的时候记录一个时刻 t1，当 t1 + rtt_var < curr_t(当前时刻)，我们就认为它丢失了。

这个时候后续的 ACK 就需要携带这个丢包信息并更新丢包时刻 t2，后续持续扫描丢包队列，如果 t2 + RTO

这种方式是由丢包请求引起的重发，如果网络很不好，接收端会不断发起重传请求，造成发送端不停的重传，引起网络风暴，通信质量会下降，**所以我们在发送端设计一个拥塞控制模块来限流**，这个后面我们重点分析。

整个请求重传机制依赖于 jitter time 和 RTO 这个两个时间参数，评估和调整这两个参数和对应的传输场景也息息相关。请求重传这种方式比定时重传方式的延迟会大，一般适合于带宽较大的传输场景，例如：视频、文件传输、数据同步等。







## FEC 选择重传

除了定时重传和请求重传模式以外，还有一种方式就是以 FEC 分组方式选择重传，FEC（Forward Error Correction）是一种前向纠错技术，一般通过 XOR 类似的算法来实现，也有多层的 EC 算法和 raptor 涌泉码技术，其实是一个解方程的过程。

**应用到 RUDP 上示意图如下：**







![img](https://pic4.zhimg.com/80/v2-821058b310e1ac7bb83ae59e17369bdf_720w.jpg)



在发送方发送报文的时候，会根据 FEC 方式把几个报文进行 FEC 分组，通过 XOR 的方式得到若干个冗余包，然后一起发往接收端，如果接收端发现丢包但能通过 FEC 分组算法还原，就不向发送端请求重传，如果分组内包是不能进行 FEC 恢复的，就向发送端请求原始的数据包。

FEC 分组方式适合解决要求延时敏感且随机丢包的传输场景，在一个带宽不是很充裕的传输条件下，FEC 会增加多余的包，可能会使得网络更加不好。FEC 方式不仅可以配合请求重传模式，也可以配合定时重传模式。





## RTT 与 RTO 的计算

在上面介绍重传模式时多次提到 RTT、RTO 等时间度量，RTT（Round Trip Time）即网络环路延时，环路延迟是通过发送的数据包和接收到的 ACK 包计算的，示意图如下：







![img](https://pic4.zhimg.com/80/v2-43b1aef1a6b3cf7883d140d5dfa5c977_720w.jpg)



**RTT = T2 - T1：**

这个计算方式只是计算了某一个报文时刻的 RTT，但网络是会波动的，这难免会有噪声现象，所以在计算的过程中引入了加权平均收敛的方法（具体可以参考 [RFC793](https://link.zhihu.com/?target=https%3A//link.jianshu.com/%3Ft%3Dhttps%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc793)）。

**SRTT = (α \* SRTT) + (1-α)RTT：**

这样可以求得逼近的 SRTT，在公式中一般α=0.8，确定了 SRTT，下一步就是计算 RTT_VAR(方差)，我们设 RTT_VAR = |SRTT – RTT|，那么 SRTT_VAR =(α * SRTT_VAR) + (1-α) RTT_VAR，这样可以得到 RTT_VAR 的值。

但最终我们是需要 RTO，因为涉及到报文重传，RTO 就是一个报文的重传周期，从网络的通信流程我们很容易知道，重传一个包以后，如果一个 RTT+RTT_VAR 之后的时间还没收到确定，那我们就可以再次重传，则可知：RTO = SRTT + SRTT_VAR。

但一般网络在严重抖动的情况下还是会有较大的重复率问题，所以：RTO = β*(SRTT + RTT_VAR)，1.2 <β<2.0，可以根据不同的传输场景来选择β的值。



## 窗口与拥塞控制

> ​	RUDP 是通过重传来保证可靠的，重传在三角平衡关系中其实是用 expense 和 latency 来换取 quality 的行为，所以重传会引来两个问题，一个是延时，一个是重传的带宽，尤其是后者，如果控制不好会引来网络风暴，所以在发送端会设计一个窗口拥塞机制了避免并发带宽占用过高的问题。





## 窗口

RUDP 需要一个收发的滑动窗口系统来配合对应的拥塞算法做流量控制，有些 RUDP 需要发送端和接收端的窗口严格地对应，有些 RUDP 不要求收发窗口严格对应。如果涉及到可靠有序的 RUDP，接收端就要做窗口排序和缓冲，如果是无序可靠或者尽力可靠的场景，接收端一般就不做窗口缓冲，只做位置滑动。

**先来看收发窗口关系图：**







![img](https://pic3.zhimg.com/80/v2-8198aef403b2e16ceb48b4609895a8e6_720w.jpg)



上图描述的是发送端从发送窗口中发了 6 个数据报文给接收端，接收端收到 101，102，103，106 时会先判断报文的连续性并滑动窗口开始位置到 103，接着每个包都回应 ACK，发送端在接收到 ACK 的时候，会确认报文的连续性，并滑动窗口到 103，发送端会再判断窗口的空余，然后填补新的发送数据，这就是整个窗口滑动的流程。

这里值的一提的是在接收端收到 106 时的处理，如果是有序可靠，那么 106 不会通知上层业务进行处理，而是等待 104、105。**如果是尽力可靠和无序可靠场景，会将 106 通知给上层业务先进行处理**。在收到 ACK 后，发送端的窗口要滑动多少是由自己的拥塞机制定的，也就是说窗口的滑动速度受拥塞机制控制，拥塞控制实现要么基于丢包率来实现，要么基于双方的通信时延来实现，下面来看几种典型的拥塞控制。



## 经典拥塞算法

TCP 经典拥塞算法分为四个部分：慢启动、拥塞避免、拥塞处理和快速恢复，这四个部分都是为了决定发送窗口和发送速度而设计的，其实就是为了在当前网络条件下通过网络丢包来判断网络拥塞状态，从而确定比较适合的发送传输窗口。

经典算法是建立在定时重传的基础上的，如果 RUDP 采用这种算法来做拥塞控制，一般的场景是为了保证有序可靠传输的同时又兼顾网络传输的公平性原则。先逐个来解释下这几部分。

**慢启动（slow start）：**

当连接链路刚刚建立后，不可能一开始将 cwnd 设置得很大，这样容易造成大量重传，经典拥塞里面会在开始将 cwnd = 1，然后根据通信过程的丢包情况来逐步扩大 cwnd 来适应当前的网络状态，直到达到慢启动的门限阈值 (ssthresh)，步骤如下：

> 1）初始化设置 cwnd = 1，并开始传输数据；
> 2）收到回馈的 ACK，会将 cwnd 加 1；
> 3）当发送端一个 RTT 后且未发现有丢包重传，就会将 cwnd = cwnd * 2；
> 4）当 cwnd >= ssthresh 或发生丢包重传时慢启动结束，进入拥塞避免状态。

**拥塞避免：**

当通信连接结束慢启动后，有可能还未到网络传输速度的上线，这个时候需要进一步通过一个缓慢的调节过程来进行适配。一般是一个 RTT 后如果未发现丢包，就将 cwnd = cwnd + 1。一但发现丢包和超时重传，就进入拥塞处理状态。

**拥塞处理：**

拥塞处理在 TCP 里面实现很暴力，如果发生丢包重传，直接将 cwnd = cwnd / 2，然后进入快速恢复状态。

**快速恢复：**

通过确认丢包只发生在窗口一个位置的包来确定是否进行快速恢复，如图 6 中描述，如果只是 104 发生了丢失，而 105 和 106 是收到了的，那么 ACK 总是会将 ACK 的 base = 103，如果连续 3 次收到 base 为 103 的 ACK，就进行快速恢复，也就是立即重传 104，而后如果收到新的 ACK 且 base > 103，将 cwnd = cwnd + 1，并进入拥塞避免状态。

经典拥塞控制是基于丢包检测和定时重传模式来设计的，在三角平衡关系中是一个典型的以 latency 换取 quality 的案例，但由于其公平性设计避免了过高的 expense，也就会让这种传输方式很难压榨网络带宽，很难保证网络的大吞吐量和小时延。

## BBR 拥塞算法

对于经典拥塞算法的延迟和带宽压榨问题 Google 设计了基于发送端延迟和带宽评估的 BBR 拥塞控制算法。

**这种拥塞算法致力于解决两个问题：**

> 1）在一定丢包率网络传输链路上充分利用带宽；
> 2）降低网络传输中的 buffer 延迟。

BBR 的主要策略是周期性通过 ACK 和 NACK 返回来评估链路的 min_rtt 和 max_bandwidth。最大吞吐量（cwnd）的大小就是：cwnd = max_bandwidth / min_rtt。

**传输模型如下：**







![img](https://pic2.zhimg.com/80/v2-a2e754d3ad80035e64e4e30164ffa70d_720w.jpg)



**BBR 整个拥塞控制是一个探测带宽和 Pacing rate 的状态，有 4 个状态：**

> 1）Startup：启动状态（相当于慢启动），增益参数为 max_gain = 2.85；
> 2）DRAIN：满负荷传输状态；
> 3）PROBE_BW：带宽评估状态，通过一个较小的 BBR 增益参数来递增（1.25）或者递减 (0.75)；
> 4）PROBE_RTT：延迟评估状态，通过维持一个最小发送窗口（4 个 MSS）进行的 RTT 采样。

**那么这几种状态是怎么来回切换的呢？以下是 QUIC 中 BBR 大致的步骤如下：**

1）初始化连接时会设置一个初始的 cwnd = 8，并将状态设置 Startup；

2）在 Startup 下发送数据，**根据 ACK 数据的采样周期性判断是否可以增加带宽**，如果可以，将 cwnd = cwnd ***max_gain**。如果时间周期数超过了预设的启动周期时间或者发生了丢包，进行 DRAIN 状态；

3）在 DRAIN 状态下，如果 flight_size(发送出去但还未确认的数据大小) >cwnd, 继续保证 DRAIN 状态，如果 flight_size

4）在PROBE_BW状态下，如果未发生丢包且flight_size cwnd，将cwnd = cwnd * 1.25，如果发生丢包，cwnd = cwnd * 0.75；

5）在 Startup/DRAIN/PROBE_BW 三个状态中，如果持续 10 秒钟的通信中没有出现 RTT <= min_rtt，就会进入到 PROBE_RTT 状态，并将 cwnd = 4 *MSS；

6）在 PROBE_RTT 状态，会在收到 ACK 返回的时候持续判断 flight_size >= cwnd 并且无丢包，将本次统计的最小 RTT 作为 min_rtt，进入 Startup 状态。

BBR 通过以上几个步骤来周期性计算 cwnd，也就是网络最大吞吐量和最小延迟，然后通过 pacing rate 来确定这一时刻发送端的码率，最终达到拥塞控制的目的。

BBR 适合在随机丢包且网络稳定的情况下做拥塞，如果在网络信号极不稳定的 Wi-Fi 或者 4G 上，容易出现网络泛洪和预测不准的问题，BBR 在多连接公平性上也存在小 RTT 的连接比大 RTT 的连接更吃带宽的情况，容易造成大 RTT 的连接速度过慢的情况。BBR 拥塞算法在三角平衡关系中是采用 expense 换取 latency 和 quality 的案例。







## 弱窗口拥塞机制

其实在很多场景是不用拥塞控制或者只要很弱的拥塞控制即可，例如：师生双方书写同步、实时游戏，因为本身的传输的数据量不大，只要保证**足够小的延时和可靠性**就行，一般会采用固定窗口大小来进行流控，**我们在系统中一般采用一个 cwnd =32 这样的窗口来做流控**，**ACK 确认也是通过整个接收窗口数据状态反馈给发送方，简单直接，也很容易适应弱网环境。**



## 重点在于足够小的延时和可靠性






























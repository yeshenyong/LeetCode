# 哈希树



> 百度百科：哈希树（或哈希特里）是一种持久性数据结构，可用于实现集合和映射，旨在替换纯函数式编程中的哈希表。 在其基本形式中，哈希树在trie中存储其键的哈希值（被视为位串），其中实际键和（可选）值存储在trie的“最终”节点中


## 哈希树的建立

![avatar](https://bkimg.cdn.bcebos.com/pic/7dd98d1001e939012e3cd9d977ec54e736d1961e?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

建树逻辑：
选择质数分辨算法来建立一棵哈希树。选择从2开始的连续质数来建立一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。同一结点中的子结点，从左到右代表不同的余数结果。例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.对质数进行取余操作得到的余数决定了处理的路径。
以随机的10个数的插入为例，来图解HashTree的插入过程。如图2。
其实也可以把所有的键-值节点放在哈希树的第10层叶节点处，这第10层的满节点数就包含了所有的整数个数，但是如果这样处理的话，所有的非叶子节点作为键-值节点的索引，这样使树结构庞大，浪费空间

## 增
    1. 一轮轮 hash，直到找到属于自己的节点
    2. hash 冲突怎么办，单节点hash 冲突可以作为其子节点进行挂载。比如一颗上图的hash 树，7807 节点和 249 节点属于hash 冲突，但7807 先插入，所以它属于父节点，后面插入的属于子节点。只要hash 树深度为常数量，则增删改查的时间复杂度都为 O(1)

## 删

    哈希树的节点删除过程也很简单，哈希树在删除的时候，并不做任何结构调整。
只是先查到到要删除的节点，然后把此节点的“占位标记”置为false即可（即表示此节点为空节点，但并不进行物理删除）

## 改

    哈希树的节点的 value 修改过程也很简单，哈希树在修改的时候，并不做任何结构调整。
    只是先查到到要修改的节点，然后将此节点的 value 值进行替换（涉及key的变化）

## 查
    同改一样，查更简单
    哈希树的节点查找过程和节点插入过程类似，就是对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。
    如最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次。也就是说：最多属于O(10)。在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。也就是说：最多属于O(5)。因此可以根据自身需要在时间和空间上寻求一个平衡点


## 优点
    1. 扩容机制不需要rehash，增删改查结构不变
    2. 查找迅速，32bit 内的int 不会超过10 次
    3. 结构简单（只需额外维护flag 与子节点指针）



## 缺点
    哈希树不支持排序，没有顺序特性。如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构


参考

https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E6%A0%91/8832600?fromModule=lemma_inlink

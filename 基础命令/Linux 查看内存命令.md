# Linux 查看内存命令



### free



```shell
free [options]
-b # 以Byte为单位显示内存使用情况；
-k # 以KB为单位显示内存使用情况；
-m # 以MB为单位显示内存使用情况；
-g # 以GB为单位显示内存使用情况。 
-o # 不显示缓冲区调节列；
-s<间隔秒数> # 持续观察内存使用状况；
-t # 显示内存总和列；
-V # 显示版本信息
```



下面先解释一下输出的内容：

| 内容              | 含义                                                         |
| :---------------- | :----------------------------------------------------------- |
| Mem               | 行(第二行)是内存的使用情况                                   |
| Swap              | 行(第三行)是交换空间的使用情况                               |
| total             | 总可用物理内存。一般是总物理内存除去一些预留的和操作系统本身的内存占用，是操作系统可以支配的内存大小。这个在v3.2.8和v3.3.10一样。这个值是/proc/meminfo中MemTotal的值。 |
| used              | 列显示已经被使用的物理内存和交换空间。在v3.2.8,这个值是(total - free)得出来的。可以说是系统已经被系统分配，但是实际并不一定正在被真正的使用，其空间可以被回收再分配的。在v3.3.10,这个值是(total - free - cache - buffers)得出来的，是真正目前正在被使用的内存。 |
| free              | 系统还未使用的物理内存。这个值是/proc/meminfo中MemFree的值   |
| shared            | 共享内存的空间。这个值是/proc/meminfo中Shmem的值             |
| buff/cache        | 列显示被 buffer 和 cache 使用的物理内存大小                  |
| available         | v3.3.10中的项。看起来这个值是可以使用的内存，不过(available + used) < total，也就是available < (free + cache + buffers)。而在v3.2.8中(free + cache + buffers)是一般认为的可用内存，既然在新版本中有这个available数据，应该是更准确的吧。毕竟并不是所有的未使用的内存就一定是可用的。这个值是取的/proc/meminfo中MemAvailable的值，如果meminfo中没有这个值，会依据meminfo中的Active(file),Inactive(file),MemFree,SReclaimable等值计算一个。 |
| -/+ buffers/cache | v3.2.8有这一行，v3.3.10 没有。其中，used 这一项是(used - buffers - cached)的值，即(total - free - buffers - cached)的值,是真正在使用的内存的值。free 这一项是(free + buffers + cached)的值，是真正未使用的内存的值。个人觉得有 -/+ buffers/cache，这一栏看的挺习惯。。不过新版本v3.3.10的used更明确。相信有不少人和我一样，刚看到v3.2.8里面的used占了这么多内存的时候，有点摸不着头脑。 |



### vmstat

​	vmstat命令是最常见的Linux/Unix监控工具，用于查看系统的内存存储信息，是一个报告虚拟内存统计信息的小工具，属于sysstat包。

​	vmstat 命令报告包括：**进程、内存、分页、阻塞 IO、中断、磁盘、CPU**。

可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。

```shell
vmstat -s(参数)

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数

vmstat 2 1

2表示每个两秒采集一次服务器状态，1表示只采集一次
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/icRxcMBeJfcibkWulcpw1BI3wVKicIHbSnuJE8T7a9dCOsYb3TiaZwxj2JRDPq9fxF5r6etEpeh5JMAkFxicqUcg6og/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这表示vmstat每2秒采集数据，按下**ctrl + c**结束程序，这里采集了3次数据我就结束了程序。

| **类别**                    | **项目**                                                 | **含义**                                                     | **说明**                                                     |
| --------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Procs****（进程）**       | r                                                        | **等待执行的任务数**                                         | **展示了正在执行和等待cpu资源的任务个数。当这个值超过了cpu个数，就会出现cpu瓶颈。** |
| B                           | 等待IO的进程数量                                         |                                                              |                                                              |
| **Memory(****内存****)**    | swpd                                                     | 正在使用虚拟的内存大小，单位k                                |                                                              |
| free                        | 空闲内存大小                                             |                                                              |                                                              |
| buff                        | 已用的buff大小，对块设备的读写进行缓冲                   |                                                              |                                                              |
| cache                       | 已用的cache大小，文件系统的cache                         |                                                              |                                                              |
| inact                       | 非活跃内存大小，即被标明可回收的内存，区别于free和active | 具体含义见：概念补充（当使用-a选项时显示）                   |                                                              |
| active                      | 活跃的内存大小                                           | 具体含义见：概念补充（当使用-a选项时显示）                   |                                                              |
| **Swap**                    | si                                                       | 每秒从交换区写入内存的大小（单位：kb/s）                     |                                                              |
| so                          | 每秒从内存写到交换区的大小                               |                                                              |                                                              |
| **IO**                      | bi                                                       | 每秒读取的块数（读磁盘）                                     | 块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytes |
| bo                          | 每秒写入的块数（写磁盘）                                 | 块设备每秒发送的块数量，单位是block                          |                                                              |
| **system**                  | in                                                       | **每秒中断数，包括时钟中断**                                 | **这两个值越大，会看到由内核消耗的cpu时间sy会越多** **秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目** |
| cs                          | **每秒上下文切换数**                                     |                                                              |                                                              |
| **CPU****（以百分比表示）** | us                                                       | 用户进程执行消耗cpu时间(user time)                           | us的值比较高时，说明用户进程消耗的cpu时间多，**但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了** |
| sy                          | 系统进程消耗cpu时间(system time)                         | sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。**这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足** |                                                              |
| Id                          | 空闲时间(包括IO等待时间)                                 | 一般来说 us+sy+id=100                                        |                                                              |
| wa                          | 等待IO时间                                               | wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。 |                                                              |



### 3. 常见问题处理

**常见问题及解决方法**

1. 如果r经常大于4，且id经常少于40，表示cpu的负荷很重。
2. 如果pi，po长期不等于0，表示内存不足。
3. 如果disk经常不等于0，且在b中的队列大于3，表示io性能不好。

- 1.如果在processes中运行的序列(process r)是连续的大于在系统中的CPU的个数表示系统现在运行比较慢,有多数的进程等待CPU。
- 2.如果r的输出数大于系统中可用CPU个数的4倍的话,则系统面临着CPU短缺的问题,或者是CPU的速率过低,系统中有多数的进程在等待CPU,造成系统中进程运行过慢。
- 3.如果空闲时间(cpu id)持续为0并且系统时间(cpu sy)是用户时间的两倍(cpu us)系统则面临着CPU资源的短缺。



#### IO/CPU/men连锁反应

```shell
1.free急剧下降
2.buff和cache被回收下降，但也无济于事
3.依旧需要使用大量swap交换分区swpd
4.等待进程数，b增多
5.读写IO，bi bo增多
6.si so大于0开始从硬盘中读取
7.cpu等待时间用于 IO等待，wa增加
```

#### 内存不足

```shell
1.开始使用swpd，swpd不为0
2.si so大于0开始从硬盘中读取
```

#### io瓶颈

```shell
1.读写IO，bi bo增多超过2000
2.cpu等待时间用于 IO等待，wa增加 超过20
3.sy 系统调用时间长，IO操作频繁会导致增加 >30%
4.wa io等待时间长
    iowait% <20%            良好
    iowait% <35%            一般
    iowait% >50%
5.进一步使用iostat观察
```

#### CPU瓶颈：load,vmstat中r列

```shell
    1.反应为CPU队列长度
    2.一段时间内，CPU正在处理和等待CPU处理的进程数之和，直接反应了CPU的使用和申请情况。
    3.理想的load average：核数*CPU数*0.7
        CPU个数：grep 'physical id' /proc/cpuinfo | sort -u
        核数：grep 'core id' /proc/cpuinfo | sort -u | wc -l
    4.超过这个值就说明已经是CPU瓶颈了
```








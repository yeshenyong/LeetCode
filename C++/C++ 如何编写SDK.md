# 如何编写SDK

摘自

https://mp.weixin.qq.com/s/6C6X8V_WoKGVE5s4pH6TcA





### **单一职责原则**

**定义**

类的设计，尽量做到只有一个可以引起它变化的原因



**理解**

单一职责原则的存在是为了保证对象的**高内聚**、保证同一对象的**细粒度**。在程序的设计上，如果我们采用了单一职责原则，那么就要注意，开发代码过程中不要设计那些功能五花八门、包含很多很多不相关的功能的类，这样的类我们可以认为是违反单一职责原则的。按照单一职责原则设计的类中，应该有且只有一个改变因素；



**举例子**

```go
package phone
// 只负责调整电话音量
type MobileSound interface {    
// 音量+    
AddSound() error    
// 音量-    
ReduceSound() error
}
// 只负责调整照片格式
type MobilePhoto interface{    
// 亮度    
Brightness() error    
// 纵横比    AspectRatio() error
}
```



这段代码是对于手机的两个类的构造，在设计的时候，我们将手机的音量控制和手机图片的调整类进行了区分，在同一个类中不同功能的共同载体分别是音量控制和图片调整，这两个类中的功能是不产生依赖的，相互平行的关系，当手机的配置发生改变，那么这两个类中的功能都会产生一定的变化；



如果我们要对其中一个类进行调整，那么只需要在相应的interface中进行功能的优化即可，不会影响到其他功能的结构。



### **开闭原则**

定义：一个软件实体，应该对扩展开放，对修改关闭；



**理解**

针对于这个问题的产生是来自于对于代码进行维护的时候，如果对旧代码进行修改，那么可能会引入错误，这可能会导致我们对整个功能进行重新架构，并且重新测试；



为了防止这种情况的发生，我们可以采用开闭原则，我们只对代码进行添加功能，扩展类中的功能，而不去修改原先的功能，这样可以避开因为修改老代码而产生的坑（深有体会）；



**举例子**

```go

// 只负责调整电话音量,同时具备一键最大和一键最小的功能
type MobileSound interface {
    // 音量+
    AddSound() error
    // 音量-
    ReduceSound() error
    // 静音
    Mute() error
    // 一键最大
    MaxSound() error
}
```

还是这个手机的类，如果后期业务需求增加，要求我们加入静音和一键音量最大的功能，那么我们可以直接在这个音量控制接口中进行功能扩展，而不是去在音量加减的功能里进行修改，这样可以避免因为对内部逻辑的调整而产生的功能架构问题。



**注意点**

开闭原则是一个非常虚的原则，我们需要在提前预期好变化并做出规划，然后需求的变化总是远远超过我们的预期，遵循这个原则我们应该把频繁变化的部分做出抽象，但却不能将每个部分都刻意的进行抽象；



**如果我们无法预期变化，就不要去做刻意的抽象，我们应该拒绝并不成熟的抽象。**



### **里氏替换原则**

**定义**

所有引用基类的地方必须能透明的使用其子类的对象；



**理解**

子类对象替换父类对象的时候，程序本身的逻辑不能发生变化，同时不能对程序的功能造成影响；

**举例**

仍然是用手机来举例子，我们定义的手机类中，加入了一个充电功能接口；



\- 其中包含了无线充电和有线充电两个功能

```go
type Charge interface {
    //有线充电
    ChargeWithLine() error
    //无线充电
    ChargeWithoutLine() error
}
```

\- 但是我们并没有想到8848钛金手机这么一款高端商务上流手机并不具备无线充电的功能；



因为我们定义的父类并不能由子类完全替换，8848也是手机，但是因为它的功能并不完全具备手机类的功能，所以导致这个问题的产生，那么如何来解决这个问题呢？



我们可以将手机类的充电功能进行拆分，在父类中，我们只定义充电功能，那么我们就可以在8848子类里面设计具体的充电方式，来完善这个功能的接口。我们在手机类中仅定义了最基础的方法集，通过子接口SpecialPhone添加ChargeWithLine方法；

```go
type MobilPhone interface {
    Name() string
    Size() int
}

type NormalCharge interface {
    MobilPhone
    ChargeWithLine() error
    ChargeWithoutLine() error
}

type SpecialCharge interface {
    MobilPhone
    ChargeWithLine() error
}
```

\- 我们再通过SpecialPhone来提供对MobilPhone的基本实现：

```go

type SpecialPhone struct {
    name string
    size int
}

func NewSpecialPhone(name string, size int) *SpecialPhone {
    return &SpecialPhone{
        name,
        size,
    }
}

func (mobile *SpecialPhone) Name() string {
    return mobile.name
}

func (mobile *SpecialPhone) Size() int {
    return mobile.size
}
```



\- 最后，Mobil8848通过聚合SpecialPhone实现MobilPhone接口, 通过提供ChargeWithLine方法实现Mobil8848子接口：

```go

type Mobil8848 struct {
    SpecialPhone
}

func NewMobil8848(name string, size int) MobilPhone {
    return &Mobil8848{
        *NewSpecialPhone(name, size),
    }
}

func (mobile *Mobil8848) ChargeWithLine() error {
    return nil
}
```



### **接口隔离原则**

同单一职责原则类似：



\- 在接口设计时，如果粒度太小会导致接口数据太多，开发人员被众多的接口淹没；

\- 如果粒度太大，又可能导致灵活性降低。无法支持业务变化；

\- 我们需要深入了解业务逻辑，不可盲目照抄大师的接口；



## 遵循的编码原则

### **稳定、高效**

公共库是提供给众多业务方使用的第三方组件，如果公共库运行时程序崩溃，会危及业务方的项目，可能会造成线上事故，所以稳定是一个公共库的基本保证。



### **暴露异常**

异常可以通过日志和接口返回暴露给用户。对于异常情况一定要打日志，方便用户排查具体问题，并且约定错误码，通过错误码和error message将错误信息暴露给用户。在公共库内部，所有可能返回错误的地方都不能忽略。

### **测试**

封装好一个函数或者功能模块后，我们需要测试其逻辑的正确性和函数的性能，这就需要单元测试和性能测试。单元测试的重点在于验证程序设计或实现的逻辑是否正确，而压力测试的重点在于测试程序性能，确认程序在高并发的情况下还能保持稳定运行。



#### **单元测试**

单元测试就是针对某一个函数或者进行测试，通过各种可能的样例（即函数的输入和期望的输出）验证函数各分支是否都得到了预期的结果，或者可能的问题都能被预知并提前处理。通过单测能解决以下问题：



\- 提早发现发现程序设计或实现上的逻辑错误，便于及时定位解决，确保每个函数是可运行的，运行结果是正确的。

\- 一次编写，多次运行。编写好一个函数的单元测试后，后续对函数的修改或重构，都可以使用此前编写的单测来确保修改后的函数依然保持正确的逻辑，防止手动测试遗漏一些边界情况，给代码留下隐患。



#### **压力测试**

压力测试的重点是测试程序在高并发的情况是否还能保持稳定运行，以及测试程序能够承受的并发量。公共库除了保证逻辑正确外，还应该保证其在高并发的情况下还能正常运行。



**3.4 保持向下兼容**



公共库应该版本向下兼容，即使更新了公共库版本的用户，其此前使用旧版本公共库的项目代码还能正常运行。

\- 公共库对外暴露的接口应该避免改动，其函数签名不应该再改动，对函数逻辑的修改应该让用户无感知。

\- 如果此前的接口确实无法满足需要，那么可以升级一个库版本，在新版本中开发一个新的接口，而不是在原版本中直接对接口进行修改。



**3.5 减少外部依赖**



公共库应该尽量减少外部依赖，应该避免使用不稳定的外部依赖。在封装公共库时，也应该精简代码与功能，以最精简的形态提供最核心的功能，避免公共库的体积过大



**3.6 易用性**



**统一调用**

SDK应主动封装复杂的调用方式，屏蔽底层复杂逻辑，尽量提供给使用方简单的调用形式。让使用者能在几行代码中实现功能，减少使用者在调⽤的流程和对参数的理解成本。同时提供友好的提示，便于使用者调用调试。



这些需要在接口设计阶段做到极致，不仅要调用简单，又在提供基础功能的基础上，支持扩展定制化。例如，我们在工程中，通常会将仅需一次加载，整个工程生命周期生效的参数配置化，以一个配置文件作统一管理。但实际上配置文件的格式分多种，例如yaml、json、xml等，可扩展性设计在对配置内容的含义、默认的配置项详细说明的基础上，支持多类配置文件的加载......等。



在接口设计时统一风格，可以给使用者留下专业的印象，同时它也可以传递出开发者SDK的设计理念。当出现跨平台同功能的使用时，可沿用平台风格，通过延续风格，让使用者更直观的调用SDK功能。



### **可理解性**



#### **目录结构**

代码的目录结构可以定义整个SDK的层次架构，我们可以通过目录大致知晓其内部实现围绕的主题。在目录结构定义上，应命名上直接突出主题，拆分明确，尽量不存在交集，不应让人去猜或等读完源码才知道在做什么。



好的拆分能避免重复代码并方便使用者查找，例如log、doc、util、config、test、build等能让人一眼明确该目录下所做的工作。同时目录层次也尽量不要太深，太深会一定程度上加重使用者负担。



#### 代码风格



### 总结

​	一个好的SDK可以减轻工作量、降低平台使用门槛、增加系统健壮性等多个好处，在本文中我们分别从设计模式、代码原则、文档、注释等多个方面描述了我们是如何在百度内部维护好一个SDK库，想要写出一个好的代码本身就不是一件容易的事情，需要我们不断的更新自己的知识体系，持续优化、重构之前的代码。



​	我们始终崇尚：每一个项目、每一行代码都应该是按照最高的标准去设计以及开发！



​	我们也一直努力能写出大师级的代码，当我们回首自己代码的时候，不因文档注释混乱而懊恼，也不因糟糕的实践而悔恨。
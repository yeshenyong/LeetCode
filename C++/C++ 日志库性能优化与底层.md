# C++ 日志库性能优化与底层

[为什么yalantinglibs.easylog 性能比spdlog 更好？ (qq.com)](https://mp.weixin.qq.com/s/lmaG5aBxzn194u6w6m6lew)

## 日期字符串的优化

事实上时间转换为日期字符串是一个非常耗时的操作，如果每条日志都生成一次日期字符串将会非常慢，但是日期字符串有一个规律，就是同一秒内的日志，只有毫秒数存在差异，而前面的内容是一样的，这就很适合做缓存了，只要时间间隔小于1 秒，那么就复用之前的日期字符串，只是把毫秒替换成最新的即可。这样把每次都需要做的日期转换变成1 秒做一次，这样就能大幅提升性能了。另外，日期字符串较长，超过了22 个字节，这么长的字符串std::string 无法做SSO 优化，将导致每次都会有堆内存的分配，为了尽可能避免额外的内存分配，easylog 使用了静态线程局部变量来做日期字符串的缓存，依赖免了堆内存的分配，而来通过缓存来优化获取日期字符串的性能

## 线程id 的优化

获取线程id 也是需要系统调用比较耗时，如果每次写日志都调用系统api 来获取线程id 也是很低效的做法，这里依然可以用缓存来优化，线程id 显然是一个static thread_local 的，无论多少日志只需要获取初始化一次线程id 即可，后面就直接拿第一次获取的线程id即可，这样就避免了每次都调用系统api 来获取线程id的低效

## 文件名行号的优化

关于这部分的性能优化方法我在2021 purecpp 大会上《使用constexpr做性能优化》里专门讲过，简单说就是把生成文件名和行号的过程放到编译期，从而消除了运行期的开销，有兴趣可以看看之前的视频内容和ppt

## 避免日志内存拷贝

日志字符串需要注意避免拷贝，很多日志库包括spdlog 是通过format 将日志内容统一格式化成一个完整的字符串再写文件的，这里必然会产生一次字符串拷贝，还有前面日志信息的汇聚也是通过内存移动和拷贝拼接成一个字符串的，这里存在大量的内存拷贝和内存移动也会影响性能，而easylog 避免了这些损耗，easylog 是直接将这些零散的日志信息一条条写文件的，没有拼接成一个长字符串再写文件，从而获得了更好的性能

## 多线程写日志优化

spdlog 多线程写日志的做法比较简单，就是一个队列加锁的实现，后台线程不断从队列中取出日志写文件，而easylog 这里使用了无锁队列，性能比有锁队列更好，所以多线程异步写日志的时候性能比spdlog 更好
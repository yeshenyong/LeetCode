# C++ unordered_map Dense Hashmap Sparse Hashmap

参考资料：

https://blog.csdn.net/jollyjumper/article/details/23627037

https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html（非常好的一篇对hashmap 的解析）

map：红黑树（ologn）

unordered_map、hash_map：hashtable

sparse hashmap: 空间高效

dense hashmap:时间高效

unordered_map使用的链表,按M分为一组,每组用链表存储数据，bits做查找。

sparse hashmap使用的数组(sparsetable),按M分为一组,每组用数组存储数据(虽然链表速度更快，但空间多),bits做查找。M越大内存overhead越小,在32位机器上是2bits,64位机器上是2.5bits,适合做持久化操作，做hash时使用二次内部探测(quadratic internal probing),一般查找需要4-5次。

dense hashmap和一般hash map实现差不多，只是冲突解决用二次内部探测，一般查找是table[i], table[i + 1],table[i + 3]这样，这些数组元素一般就大一个缓存行内，因此很高效，使用内存比标准的hash map多，但是性能可以到两倍左右。另外其中判断empty,delete,是在entry上做的，需要set_empty_ key,set_deleted_key。

![image](https://s1.328888.xyz/2022/09/03/knQeN.png)

## 分析

我们可以看到，由于缓存友好，使用开放寻址的哈希映射为链接提供了一种有利的替代方案。在整数和小字符串读取测试中，它们中的大多数能够在仅加载一两个缓存行的同时找到密钥，这会产生显着差异。在插入时，与使用链接的哈希映射相比，它们还可以避免大量分配，在每次插入时必须为节点分配内存（自定义分配器可以改进）。

在字符串测试中，我们可以看到将散列值与值一起存储可以极大地促进插入，因为我们不必在重新散列和查找时重新计算散列，因为我们只在存储散列时比较两个字符串是平等的，避免昂贵的比较。请注意，如果它可以检测到由于对齐而不会占用更多内存，则`tsl::robin_map`自动存储散列并在重新散列（但不是在没有显式的查找时）使用它。它解释了为什么即使没有参数`StoreHash`，字符串插入测试也会快得多。`StoreHash`

关于负载因子，当负载因子高于 0.5 时，大多数开放寻址方案都会得到不好的结果，即使使用 robin hood 探测（请参阅[附加测试](https://tessil.github.io/other/hash_table_benchmark.html)）。Only`tsl::hopscotch_map`能够很好地应对像 0.9 这样的高负载因子，而不会在查找速度上损失太多，从而在速度和内存使用之间实现了非常好的折衷。

关于内存使用，每次速度测试都以一点内存增加的价格`tsl::sparse_map`击败。`google::sparse_hash_map`即使插入速度有点慢，它在内存使用和查找速度之间提供了令人印象深刻的平衡。

在基准测试中，我们`std::hash`在所有测试中都使用了 as 哈希函数的 Clang 实现。哈希的这种实现只使用了恒等函数，其他一些哈希函数可能会在一些哈希映射实现上给出更好的结果（特别是在随机洗牌整数插入测试中的结果很糟糕）`emilib::HashMap`。`google::sparse_hash_map`可以测试更健壮的散列函数。也可以测试一个糟糕的哈希函数，以检查每个哈希映射如何能够应对糟糕的哈希分布。

该基准专门针对哈希图。更好的结构（如尝试）可用于将字符串映射到值，但这`std::string`是一个熟悉的示例，用于测试更大的键，`int64_t`并且如果由于其内存间接性而足够大，则可能会在比较时导致缓存未命中。

总之，即使`std::unordered_map`是一个很好的实现，如果您需要更好的性能或者如果您的哈希映射使用太多内存，则可能值得检查替代方案。



### 我应该选择哪个哈希图？

每个哈希图都有其优点和不便之处，因此可能很难选择正确的。以下是一些一般性建议，具体取决于您的用例。

**默认。**在选择哈希图之前，请先尝试`std::unordered_map`. 尽管由于链接的缓存不友好性，它不是最快的哈希映射，但标准哈希映射在大多数情况下运行良好。外部库是额外的维护成本，如果您不在哈希映射上进行大量操作，`std::unordered_map`就可以了。

**为了速度效率。**使用开放寻址方案的哈希映射应该是您的选择，我建议使用 hopscotch 散列或使用or的`tsl::hopscotch_map`线性 robin hood 散列。`tsl::robin_map``ska::flat_hash_map`

两者在低负载因子下具有非常相似的查找速度，但`tsl::hopscotch_map`主要优点是能够更好地应对高负载因子（> 0.6），从而在速度和内存使用之间提供更好的折衷。

hopscotch hashing 的主要缺点是它可能会在桶附近遭受相当多的聚类，这可能会导致大量的重新散列。在使用模板参数存储哈希时`StoreHash`，还需要减小邻域的大小，这可能会加深之前的问题。但这不应该是一个好的散列函数的问题。

另一方面，`tsl::robin_map`在大多数情况下可以免费存储散列，并且在检测到这些情况时会自动这样做以加快重新散列过程。由于映射只需要存储桶中的几个字节来记账，因此它使用由于内存对齐而剩余的空间来存储部分哈希。它还提供了更快的`tsl::robin_map`插入速度，`tsl::hopscotch_map`并且能够更好地应对较差的哈希函数。

二次探测`google::dense_hash_map`也可能是一个不错的选择，但不能很好地应对高负载因子，因此需要更多内存。它在读取未命中方面也做得很差。线性探测`emilib::HashMap`也存在同样的问题。

所以最后我会建议两者都尝试一下`tsl::hopscotch_map`，`tsl::robin_map`看看哪一个最适合你的用例。作为基本准则，`tsl::hopscotch_map`如果您不想使用太多内存并且`tsl::robin_map`速度是最重要的，则更喜欢。

**为了内存效率。**如果您使用简单的键比较器存储小对象（< 32 字节），`tsl::sparse_map`那么您应该使用哈希映射。尽管插入速度很慢，但它在查找速度和内存使用之间提供了良好的平衡，即使在低负载因子下也是如此。它也比两者都快`google::sparse_hash_map`，`spp::sparse_hash_map`同时提供更多功能。

当使用非平凡的键比较器处理较大的对象时，也可以，但即使您不需要保留插入顺序，`tsl::sparse_map`您也可能想尝试一下。`tsl::ordered_map`它可以非常快速地增长映射，因为它永远不需要将键值移动到删除之外，并在查找时提供良好的性能，同时保持低内存使用。对于具有微不足道的键比较器的较小对象，它仅与`std::unordered_map`查找一样好。

**对于字符串作为键。**如果您使用字符串作为键，上述建议仍然适用，但您可能还想尝试`tsl::array_map`. 它提供了对大字符串的最佳查找速度之一，同时内存使用量最低。主要缺点是重新哈希过程很慢，并且需要一些空闲内存来将字符串从旧映射复制到新映射（它不能`std::move`用作其他哈希映射`std::string`用作键）。但是如果你事先知道项目的数量，你可以调用该`reserve`函数来避免这个问题。

如果您需要一种更紧凑的方式来存储字符串，您也可以考虑使用 trie，尤其是[`tsl::htrie_map`](https://github.com/Tessil/hat-trie)，即使您不需要进行任何前缀搜索。HAT-trie 提供了一种非常节省内存的方式来存储字符串，而不会在查找速度上损失太多。

**对于大型物体。**在处理需要时间复制或移动的大型对象时，使用开放寻址不是一个好主意。在插入时，可能必须移动值，因为它是插入过程的一部分（跳房子散列、罗宾汉散列、布谷鸟散列……）或由于重新散列。最好坚持`std::unordered_map`哪个可以只移动指向节点的指针，或者最终`tsl::ordered_map`只需要在删除时移动一个元素。

最后，这些是基于使用特定编译器的一些人工用例的基准的一些基本建议。最好的办法仍然是挑选一些候选人并在您的环境中使用您的代码对其进行测试。














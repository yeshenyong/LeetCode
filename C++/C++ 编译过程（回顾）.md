# C++ 编译过程

回顾

四个步骤

- 预处理
- 编译
- 汇编
- 链接



### 预处理

这个阶段本质上还没有进行编译，在 C++ 中，预处理器指令以 # 号开头，比如 #include、#define 和 #if 等。在这一阶段，编译器逐个处理 C++ 源码文件。对于 #define 指令，编译器将源码中的宏替换成宏定义中的内容；对于 #if、#ifdef 和 #ifndef 指令，编译器将有选择地跳过或选中部分源代码。还有去除注释等操作。

例如： C++ 代码中常用某些宏 例如 WIN  配合 #ifdef 和 #ifndef 指令 来区分不同平台，因为不同的系统提供的系统调用是不一样的.

   使用宏就可以轻松的指定这份代码按照对应的平台进行编译。那么在预编译时，编译器就会根据当前定义的宏，忽略不需要的代码

另外，在这个阶段会将用户自定义的宏进行展开，将其变成真正的代码。 例如有些库会提供 DISALLOW_COPY 这个宏来声明某个类不支持拷贝。编译器会根据宏的定义将其变成对应的  A(const & A) =delete;

**预处理阶段实际上只是一个文本处理阶段，会根据对应的预处理指令，对现有代码进行调整**

### 编译和汇编

这个阶段就是真正的编译阶段， 在这一阶段，编译器通过两个连续的步骤，将预处理器产生的代码编译成目标文件（object file），这个目标文件一般是.o 后缀，是一个二进制文件。其中编译阶段会进行词法分析和语法分析，将C++代码编译成汇编代码， 而汇编阶段将会把上一步得到的汇编代码转换成机器码，这一步骤就是根据汇编码和机器码的对应表进行一一映射。

 该阶段编译的都是.cpp 文件，.h 文件是不会进行编译的，因为头文件的内容已经在上一步（预处理和预编译阶段） 被展开在cpp文件里了。因为处理#include 指令，对应的cpp文件会把.h 文件的所有内容在自己的文件内再复制一份。基于这个原因，我们需要在头文件中使用某些宏进行防重入， 例如 #ifndef #define 组合 或者#pragma once。

因为在代码中很容易 重复引入多次头文件，大部分是由于间接引入， 这个时候如果没有防重入就会把头文件拷贝两次，造成类和变量的重复定义。 而CPP 文件就不需要这样的防重入机制。

头文件的函数声明相当于告诉了其他文件这个函数的调用入口，而真正的函数实现在对应的 .o文件，这样做的目的是 最小限度的编译代码。当你想修改.cpp文件里的函数实现时，编译器只需要重新编译单个文件。因为头文件的结构没有改动，也就是函数入口没有改动，其他文件不需要重新编译。但是当你改动了头文件中任何东西，直接饮用或间接引用该文件的所有.cpp文件都需要重新编译。所以我们在编写代码的时候，除了一些简单的get set函数，尽量都在cpp文件中进行时间，以减少改动后的编译时间。

 另外 由于每个文件都是单独编译的，而第一步预编译阶段已经把 #include 指令展开了，所以这一步骤可以完全的多线程执行，充分发挥多核CPU的优势，有多少核就能用多少核。

### 链接

经过编译阶段，所有C++代码都已经编译成机器码，但它们都是单个文件编译的，所以此时的代码还不能使用，需要用某种方法将他们串起来，这个步骤就称为链接阶段，这个阶段往往会出现很多问题，但是只要我们了解了编译过程，这些问题也就不难了。

在上一个阶段我们分析过，在每个cpp 文件单独编译时，当调用其他文件的函数时会通过函数入口找到真正的实现。当然使用其他文件的变量也需要从对应的.o文件中找到实现才能使用。

当我们在头文件中直接实现函数（不是类内的成员函数），并被多个文件引用会发生什么问题呢？

**以下例子仅适用于非成员函数，成员函数由于有其所在的作用域，不会产生冲突**

```cpp
// add.h
 
int add (int a , int b) { return a+b; }
 
 
// B.cpp
 
#include "add.h"
 
 
//main.cpp
 
#include "add.h"
int main() {
  return add(1,2);
}
```

当编译过程中的时候，B.cpp 中由于 #include “add.h” 的预处理命令会实现而非只是声明add 函数，同时 main.cpp 也因为同样的原因实现了add函数，但B.cpp 和main.cpp文件都是单独编译的，它们彼此不知道对方的存在，但进入链接阶段问题就来了。链接器在寻找add函数实现的时候发现B.o 和 main.o 中各实现了一份，这就会产生链接错误，链接器不知道该使用哪一份。

由上述分析可以知道，我们尽量不要在头文件中实现函数（成员函数没有问题）。 当然 include一个 .cpp 文件更是严重的错误。








# C++ 动态链接库工作原理



动态链接通常运用 > 静态链接



一个简单的例子

```sh
# 编译一个最简单的C 语言程序, 就会发现用到了一个动态链接库
readelf -d main | grep NEEDED
# 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6] C 语言运行时库, 里面提供了常用的IO、文件、字符串处理等功能
nm -D /lib/x86_64-linux-gnu/libc.so.6
#0000000000159c20 T xdr_netnamestr@GLIBC_2.2.5
#0000000000164010 T xdr_netobj@GLIBC_2.2.5
#0000000000163de0 T xdr_opaque@GLIBC_2.2.5
#0000000000156fa0 T xdr_opaque_auth@GLIBC_2.2.5
#0000000000156300 T xdr_pmap@GLIBC_2.2.5
#0000000000156360 T xdr_pmaplist@GLIBC_2.2.5
#0000000000164f70 T xdr_pointer@GLIBC_2.2.5
#...

# 提问: 为什么编译器默认不使用静态链接呢
# 1. 静态链接最大的问题在于生成的文件体积大、并且相当耗费内存资源与磁盘资源 (比如libc.so 是所有C 语言都会用到的运行时库, 生成代码就达到2M) 将所有的模块合并成一个可执行文件, 会修改模块之间的跳转地址, 也叫重定位. 而动态链接将链接的过程推迟到了程序加载的时候
# 2. 不同极有可能都包含相同的功能和代码 (代码复用+重定向)
# 3. 动态库优势的本身, 只需要更新动态库本身, 而不用重新编译其它组件

# 原理:将共享的代码单独出来, 保存成一个独立的动态链接库, 等到程序运行的时候才将它们加载到内存, 这不但可以节省空间, 因为同一个模块在内存中只需要保留一份副本, 可以被不同的进程所共享

# -shared 表明这是一个共享库 (Shared Library or Shared Object)
# -fPIC 将代码编译成位置无关码, 不需要加载到特定的地址, 加载到任意地址都可以运行 (生成与位置无关代码)
# -o 指定了输出的文件名
# .so Linux 的动态库扩展名 .dll 是windows 下的
gcc -shared -fPIC math.c -o libmath.so

# 需要指定 —l参数, 告知编译器与之前创建的libmath.so 进行动态链接
# 需要指定 -L指定动态库搜寻路径 (Linux 只会从LD_LIBRARY_PATH + /usr/local/lib 默认的搜索路径下搜索动态库)
gcc main.c -lmath -L. -O main
# ./main: error while loading shared libraries: libmath.so: cannot open shared object file: No such file or director
# 解法1 : cp libmath.so /usr/local/lib (need root)
# 解法2 : export LD_LIBRARY_PATH="$(pwd)" echo $LD_LIBRARY_PATH (这样操作系统会先在指定路径下去搜索, 找不到的话再去搜索系统路径)

# 程序运行时, 会将它用到的程序的数据、代码和一系列动态库加载到内存 (递归嵌套加载)
# 1. 每一个动态库的加载地址都是不固定的, os 根据当前地址空间的使用情况, 为它们动态分配一段内存, 当动态库被加载到内存以后, 一旦内存地址被确定, 就可以去修正那些函数跳转地址了 (重定位 Relocation) 这些地址在程序加载之前不过只是一堆占位符而已 (但如果直接去修改代码段中的跳转地址, 也就无法实现动态库的共享原理)
# 2. 动态链接采用做法, 不再修改代码段, 而是在数据段中专门预留一片区域用来存放函数的跳转地址 (.got Global Offset Table 全局偏移表) 里面专门用来存放全局变量和函数的跳转地址 => 于是在调用函数的时候, 会首先查表, 然后根据表中的地址来进行跳转 (这些地址在动态库加载的时候会被修改成真正的地址)
# 3. 查表的过程实现。由于全局偏移表(got) 与代码段的相对位置是固定的, 完全可以利用CPU 的相对寻址来实现 => 由于got 的存在, 不用去修改代码段, 因此代码可以被所有进程共享, 而全局偏移表虽然在每一个进程中保留一份负样本, 暂用空间很小
# 4. 采用这种方式实现的动态链接也被叫做 PIC (Position Independent Code) 地址无关代码。由于动态链接在程序加载的时候需要对大量函数进行重定位, 这一步显然是非常耗时的, 为了降低开销, 操作系统还做了一些其它优化 => (延迟绑定PLT 程序链接表, 准确来说延迟绑定使用了PLT (Procedure Linkage Table) 结构. 与其在程序一开始就对所有函数进行重定位, 不如将这个过程推迟到函数第一次被调用的时候。因果绝大多数动态库中的函数可能在程序运行期间一次都不会被使用到) => 大概思路(got 中的跳转地址默认会指向一段辅助代码, 也被叫做桩代码(Stub) .plt 存在于代码段中。第一次调用函数的时候, 这段代码会负责查询真正函数的跳转地址, 并且去更新 got表, 于是再次调用函数的时候就会直接跳转到动态库中真正的函数实现当中) 总而言之：动态链接将链接的整个过程，比如符号查询、地址的重定位从编译时推迟到了程序的运行时 (牺牲了一定的性能和一定的加载时间, 因为动态链接能够更有效的利用磁盘资源和内存资源, 也极大方便了代码的更新和维护, 更关键的是，它实现了二进制级别的代码复用)
# $ 表示后台执行, $! 替换为上一个后台进程的pid
./main > /dev/null &
cat /proc/$!/maps
```

总结：因为动态链接能够更有效的利用磁盘资源和内存资源, 也极大方便了代码的更新和维护，更关键的是，它实现了二进制级别的代码复用

![img](https://pic1.zhimg.com/80/v2-e9dbb294b84b2df684e98a0dd126fbdc_720w.webp)



动态链接库的代码段在不同进程间共享是怎么做到的？主要依赖两种技术：

- 段页式内存管理：将共享库的代码段的PA通过页表映射到对应进程的VA即可。
- **地址无关代码：库文件是经过特殊处理的，称之为地址无关代码(PIC, position-independent code)，只有这样这同一份代码映射到不同VA之后才能正常工作。**

**地址无关代码必须经过地址转换才能被处理器执行，这个转换过程是（内存中同一份）共享库（在各个进程中都能）正常执行的核心所在，被设计的非常的巧妙**












# **volatile关键字和GCC内联汇编**

摘自：https://zhuanlan.zhihu.com/p/41872203

volatile关键字声明的变量，其最重要的作用是：告诉编译器，某些不被编译器可知的因素也可以修改该变量的值，包括操作系统、硬件、多线程等，

所以使用这个变量的代码部分不能做编译优化，从而让编译器每次需要读取该变量的值时必须从该变量的地址（内存）中读，这样就会保证不会出错。

如果存在编译优化的话，变量值可能被某些不被编译器可知的因素偷偷修改，但是编译器从就近读过的值（优化方式）直接读取，会出错，volatile能保证代码一定不被优化，每次都从地址读取，就保证了不会出错！

[更详细的解释](https://www.huaweicloud.com/articles/e4e3ee53e594c40a9ad3da9687f94bc7.html)

GCC允许C/C++中嵌入汇编语言,以解决C/C++无法处理的问题或者使用更简介的汇编来表达

这就叫GCC内联汇编, GCC Inline ASM

__asm__ 是汇编asm的宏定义, 是一切内联汇编的开头

__volatile__ 是c++关键字volatile的宏定义, __asm__ __volatile__("指令列表")表达不要优化写的汇编指令

__asm__("":::"memory")声明此处内存可能发生了编译器察觉不到的变化,让编译器不再使用优化,老老实实从内存读取并生成不优化的汇编指令

> 它告诉编译器：这条指令（其实是空的）可能会读取任何内存地址，也可能会改写任何内存地址。那么编译器会变得保守起来，它会防止这条fence命令上方的内存访问操作移到下方，同时防止下方的操作移到上面，也就是防止了乱序，是我们想要的结果。 但这还没完，这条命令还有另外一个副作用：它会让编译器把所有缓存在寄存器中的内存变量flush到内存中，然后重新从内存中读取这些值。